{"version":3,"sources":["../../../src/mocks/mock-utils.js"],"sourcesContent":["import { isPlainObject, validKeys, buildRecursive } from '../utils/index'\n\nexport function toSortedQueryString(entry) {\n  if (!isPlainObject(entry)) {\n    return entry\n  }\n\n  return validKeys(entry)\n    .sort()\n    .map((key) => {\n      const value = entry[key]\n\n      if (isPlainObject(value)) {\n        return toSortedQueryString(value)\n      }\n\n      return buildRecursive(key, value)\n    })\n    .join('&')\n    .replace(/%20/g, '+')\n}\n\n/**\n * Filters an `object` by keeping only the keys fulfilling the `predicate`\n *\n * @param {Object} object - An object\n * @param {Function} predicate - A function of type (key: string) => boolean\n * @returns {Object} The filtered object\n */\nfunction filterByPredicate(object, predicate) {\n  return Object.entries(object)\n    .filter(([key]) => predicate(key))\n    .reduce((acc, [key, value]) => ({ ...acc, [key]: value }), {})\n}\n\n/**\n * Verify if the object `A` is contained within object `B` - shallowly.\n * In other words, is A a subset of B?\n *\n * @see https://en.wikipedia.org/wiki/Subset\n *\n * @param {Object} A - The object to test\n * @param {Object} B - The superset object to verify against\n * @returns A boolean representing if A is a shallow subset of B\n */\nexport function isSubset(A, B) {\n  // Make B only contain the non-nullish keys it has in in common with A\n  const keysFromA = validKeys(A)\n  const filteredB = filterByPredicate(B, (keyFromB) => keysFromA.includes(keyFromB))\n\n  return toSortedQueryString(A) === toSortedQueryString(filteredB)\n}\n\n/**\n * Sort the query params on a URL based on the 'key=value' string value.\n * E.g. /example?b=2&a=1 will become /example?a=1&b=2\n *\n * @param {String} url - a URL that should be sorted (with or without query params)\n */\nexport function sortedUrl(url) {\n  const urlParts = url.split('?')\n  if (urlParts.length > 1) {\n    const query = urlParts[1]\n    const sortedQuery = query.split('&').sort().join('&')\n    return `${urlParts[0]}?${sortedQuery}`\n  } else {\n    return urlParts[0]\n  }\n}\n"],"mappings":";AAAA,SAAS,eAAe,WAAW,sBAAsB;AAElD,SAAS,oBAAoB,OAAO;AACzC,MAAI,CAAC,cAAc,KAAK,GAAG;AACzB,WAAO;AAAA,EACT;AAEA,SAAO,UAAU,KAAK,EACnB,KAAK,EACL,IAAI,CAAC,QAAQ;AACZ,UAAM,QAAQ,MAAM,GAAG;AAEvB,QAAI,cAAc,KAAK,GAAG;AACxB,aAAO,oBAAoB,KAAK;AAAA,IAClC;AAEA,WAAO,eAAe,KAAK,KAAK;AAAA,EAClC,CAAC,EACA,KAAK,GAAG,EACR,QAAQ,QAAQ,GAAG;AACxB;AASA,SAAS,kBAAkB,QAAQ,WAAW;AAC5C,SAAO,OAAO,QAAQ,MAAM,EACzB,OAAO,CAAC,CAAC,GAAG,MAAM,UAAU,GAAG,CAAC,EAChC,OAAO,CAAC,KAAK,CAAC,KAAK,KAAK,OAAO,EAAE,GAAG,KAAK,CAAC,GAAG,GAAG,MAAM,IAAI,CAAC,CAAC;AACjE;AAYO,SAAS,SAAS,GAAG,GAAG;AAE7B,QAAM,YAAY,UAAU,CAAC;AAC7B,QAAM,YAAY,kBAAkB,GAAG,CAAC,aAAa,UAAU,SAAS,QAAQ,CAAC;AAEjF,SAAO,oBAAoB,CAAC,MAAM,oBAAoB,SAAS;AACjE;AAQO,SAAS,UAAU,KAAK;AAC7B,QAAM,WAAW,IAAI,MAAM,GAAG;AAC9B,MAAI,SAAS,SAAS,GAAG;AACvB,UAAM,QAAQ,SAAS,CAAC;AACxB,UAAM,cAAc,MAAM,MAAM,GAAG,EAAE,KAAK,EAAE,KAAK,GAAG;AACpD,WAAO,GAAG,SAAS,CAAC,CAAC,IAAI,WAAW;AAAA,EACtC,OAAO;AACL,WAAO,SAAS,CAAC;AAAA,EACnB;AACF;","names":[]}